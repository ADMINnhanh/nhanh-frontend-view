import{dt as Y}from"./index-EfoIWUQ8.js";class C{static isOverlap(...n){let t=[];return n.some(r=>{const e=`${r.x}${r.y}`;if(t.includes(e))return!0;t.push(e)})}static isAxisOverlap(...n){let t=[],r=[];return n.forEach(e=>{t.includes(e.x)||t.push(e.x),r.includes(e.y)||r.push(e.y)}),t.length==1||r.length==1}static calculateLineParameters(n,t){if(n.x===t.x&&n.y===t.y)throw new Error("两点重合，无法确定直线");if(n.x===t.x)return null;const r=(t.y-n.y)/(t.x-n.x),e=n.y-r*n.x;return{slope:r,intercept:e}}static calculateXFromY(n,t,r){const e=C.calculateLineParameters(n,t);if(e){const{slope:s,intercept:i}=e;return(r-i)/s}else return n.x}static calculateYFromX(n,t,r){const e=C.calculateLineParameters(n,t);if(e){const{slope:s,intercept:i}=e;return s*r+i}else return null}static perpBisectorByScope(n,t,r,e){if(C.isOverlap(n,t))return;const s=(n.x+t.x)/2,i=(n.y+t.y)/2;if(n.x===t.x)return{x:{...r},y:{min:i,max:i}};if(n.y===t.y)return{x:{min:s,max:s},y:{...e}};const m=-1/((t.y-n.y)/(t.x-n.x)),l=[],h=o=>{const y=m*(o-s)+i;y>=e.min&&y<=e.max&&l.push({x:o,y})},B=o=>{const y=(o-i)/m+s;y>=r.min&&y<=r.max&&l.push({x:y,y:o})};h(r.min),h(r.max),B(e.min),B(e.max);const c=[];for(const o of l)c.some(y=>Math.abs(o.x-y.x)<1e-10&&Math.abs(o.y-y.y)<1e-10)||c.push(o);if(c.length<2)return;const v=c.reduce((o,y)=>!o||(o==null?void 0:o.x)>y.x?y:o),f=c.reduce((o,y)=>!o||(o==null?void 0:o.x)<y.x?y:o);return{x:{min:v.x,max:f.x},y:{min:v.y,max:f.y}}}static getAngleBisector(n,t,r,e,s){const i={x:n.x-t.x,y:n.y-t.y},x={x:r.x-t.x,y:r.y-t.y},m=Math.sqrt(i.x*i.x+i.y*i.y),l=Math.sqrt(x.x*x.x+x.y*x.y);if(m<1e-10||l<1e-10)return null;const h={x:i.x/m,y:i.y/m},B={x:x.x/l,y:x.y/l},c={x:h.x+B.x,y:h.y+B.y},v=Math.sqrt(c.x*c.x+c.y*c.y);if(v<1e-10)return null;const f={x:c.x/v,y:c.y/v},o=[],y=a=>{const u=t.x+a*f.x,d=t.y+a*f.y,A=1e-8,g=Math.abs(u-e.min)<A||Math.abs(u-e.max)<A,p=Math.abs(d-s.min)<A||Math.abs(d-s.max)<A;if((u>=e.min||Math.abs(u-e.min)<A)&&(u<=e.max||Math.abs(u-e.max)<A)&&(d>=s.min||Math.abs(d-s.min)<A)&&(d<=s.max||Math.abs(d-s.max)<A)&&(g||p)){const P=g?Math.abs(u-e.min)<A?e.min:e.max:u,L=p?Math.abs(d-s.min)<A?s.min:s.max:d;o.push({point:{x:P,y:L},t:a})}};if(Math.abs(f.x)>1e-10){const a=(e.min-t.x)/f.x,u=(e.max-t.x)/f.x;y(a),y(u)}if(Math.abs(f.y)>1e-10){const a=(s.min-t.y)/f.y,u=(s.max-t.y)/f.y;y(a),y(u)}const M=[],q=1e-8;for(const a of o)M.some(d=>Math.abs(d.point.x-a.point.x)<q&&Math.abs(d.point.y-a.point.y)<q)||M.push(a);if(M.sort((a,u)=>a.t-u.t),M.length===1){const u=[M[0].t-1e3,M[0].t+1e3],d=[];for(const A of u){const g=t.x+A*f.x,p=t.y+A*f.y;g>=e.min&&g<=e.max&&p>=s.min&&p<=s.max&&d.push({x:g,y:p})}if(d.length>0)return[M[0].point,d[0]]}return M.length<2?null:[M[0].point,M[M.length-1].point]}static getPerpendicularBisectorRightAngleSymbol(n,t,r){if(C.isOverlap(n,t,r)||C.isAxisOverlap(n,t,r))return;const e={x:t.x-n.x,y:t.y-n.y},s=Math.hypot(e.x,e.y);if(s<1e-10)return;const i={x:e.x/s,y:e.y/s},x={x:(n.x+t.x)/2,y:(n.y+t.y)/2},m={x:r.x-x.x,y:r.y-x.y},l={x:e.y,y:-e.x},h={x:-e.y,y:e.x},c=l.x*m.x+l.y*m.y>=0?l:h,v=Math.hypot(c.x,c.y),f={x:c.x/v,y:c.y/v},o=Math.hypot(t.x-n.x,t.y-n.y),y=Math.hypot(r.x-t.x,r.y-t.y),M=Math.hypot(n.x-r.x,n.y-r.y),q=Math.min(o,y,M);if(q<1e-10)return;const a=Number((q/10).toFixed(2)),u={x:x.x+a*f.x+a*i.x,y:x.y+a*f.y+a*i.y},d={x:u.x-a*i.x,y:u.y-a*i.y},A={x:u.x-a*f.x,y:u.y-a*f.y};return[d,u,A]}static calculatePerpendiculars(n,t,r){const e={x:n.x-t.x,y:n.y-t.y},s={x:r.x-t.x,y:r.y-t.y},i=Math.sqrt(e.x*e.x+e.y*e.y),x=Math.sqrt(s.x*s.x+s.y*s.y),m={x:e.x/i,y:e.y/i},l={x:s.x/x,y:s.y/x},h={x:m.x+l.x,y:m.y+l.y},B=Math.sqrt(h.x*h.x+h.y*h.y),c={x:h.x/B,y:h.y/B},v=Math.min(i,x),f={x:t.x+c.x*v,y:t.y+c.y*v},o=(g,p)=>{const P={x:f.x-t.x,y:f.y-t.y},L=P.x*p.x+P.y*p.y;return{x:t.x+p.x*L,y:t.y+p.y*L}},y=(g,p)=>{let P={x:-g.y,y:g.x};return P.x*p.x+P.y*p.y<0&&(P={x:g.y,y:-g.x}),P},M=o(e,m),q=y(m,c),a=o(s,l),u=y(l,c),d=(g,p)=>[g,p],A=(g,p,P)=>{const L=Math.min(i,x)*.1,F={x:g.x-p.x*L,y:g.y-p.y*L},D={x:g.x+P.x*L,y:g.y+P.y*L},X={x:F.x+P.x*L,y:F.y+P.y*L};return[F,X,D]};return{ab:{perpendicular:d(f,M),rightAngleSymbol:A(M,m,q)},bc:{perpendicular:d(f,a),rightAngleSymbol:A(a,l,u)}}}static getRightAngleSymbol(n,t,r){const e={x:t.x-n.x,y:t.y-n.y},s={x:r.x-n.x,y:r.y-n.y},i=Math.sqrt(e.x*e.x+e.y*e.y),x=Math.sqrt(s.x*s.x+s.y*s.y);if(i===0||x===0)return[n,n,n];const m={x:e.x/i,y:e.y/i},l={x:s.x/x,y:s.y/x},h=Math.min(i,x)*.2,B={x:n.x+h*m.x,y:n.y+h*m.y},c={x:n.x+h*l.x,y:n.y+h*l.y},v={x:B.x+h*l.x,y:B.y+h*l.y};return[B,v,c]}static rotatePoints(n,t,r){const e=n[t],s=e.x,i=e.y,x=Math.cos(r),m=Math.sin(r);return n.map(l=>{const h=l.x-s,B=l.y-i,c=s+h*x-B*m,v=i+h*m+B*x;return{x:c,y:v}})}static getPerpendicularLines(n,t){const r=(n.x+t.x)/2,e=(n.y+t.y)/2,s=C.calculateLineParameters(n,t);if(s){if(s.slope==0)return{x:r};const i=-1/s.slope,x=e-i*r;return{slope:i,intercept:x}}return{slope:0,intercept:e}}static circumcircle(n,t,r){if(C.isOverlap(n,t,r))return;const e=C.getPerpendicularLines(n,t),s=C.getPerpendicularLines(t,r);if("x"in e&&"x"in s)return;let i,x,m;return"x"in e||"x"in s?"x"in e?(i=e.x,x=s.slope*i+s.intercept):(i=s.x,x=e.slope*i+e.intercept):(i=(e.intercept-s.intercept)/(s.slope-e.slope),x=e.slope*i+e.intercept),m=Y(n.x,n.y,i,x),{x:i,y:x,r:m}}static transform(n){return Array.isArray(n)?n.map(t=>this.transform(t)):[n.x,n.y]}static inverseTransform(n){return Array.isArray(n)&&Array.isArray(n[0])?n.map(t=>this.inverseTransform(t)):{x:n[0],y:n[1]}}}class I{constructor(n){this.abc=n,this.abc=n}v(n){if(!this.abc.value)return{x:0,y:0};const t=this.abc.value[n];return{x:t[0],y:t[1]}}get a(){return this.v(0)}get b(){return this.v(1)}get c(){return this.v(2)}p(n){if(!this.abc.finalDynamicPosition)return{x:0,y:0};const t=this.abc.finalDynamicPosition[n];return{x:t[0],y:t[1]}}get ap(){return this.p(0)}get bp(){return this.p(1)}get cp(){return this.p(2)}static getMid(n,t){return!n.value||!t.value?[0,0]:[(n.value[0]+t.value[0])/2,(n.value[1]+t.value[1])/2]}static join(...n){return n.map(t=>t.value&&[t.value[0],t.value[1]]).filter(Boolean)}}export{I as A,C as M};
